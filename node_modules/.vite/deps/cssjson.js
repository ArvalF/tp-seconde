import {
  __commonJS
} from "./chunk-UV5CTPV7.js";

// node_modules/cssjson/cssjson.js
var require_cssjson = __commonJS({
  "node_modules/cssjson/cssjson.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.CSSJSON = factory();
      }
    })(exports, function() {
      var CSSJSON = new function() {
        var base = this;
        base.init = function() {
          String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, "");
          };
          String.prototype.repeat = function(n) {
            return new Array(1 + n).join(this);
          };
        };
        base.init();
        var selX = /([^\s\;\{\}][^\;\{\}]*)\{/g;
        var endX = /\}/g;
        var lineX = /([^\;\{\}]*)\;/g;
        var commentX = /\/\*[\s\S]*?\*\//g;
        var lineAttrX = /([^\:]+):([^\;]*);/;
        var altX = /(\/\*[\s\S]*?\*\/)|([^\s\;\{\}][^\;\{\}]*(?=\{))|(\})|([^\;\{\}]+\;(?!\s*\*\/))/gmi;
        var capComment = 1;
        var capSelector = 2;
        var capEnd = 3;
        var capAttr = 4;
        var isEmpty = function(x) {
          return typeof x == "undefined" || x.length == 0 || x == null;
        };
        base.toJSON = function(cssString, args) {
          var node = {
            children: {},
            attributes: {}
          };
          var match = null;
          var count = 0;
          if (typeof args == "undefined") {
            var args = {
              ordered: false,
              comments: false,
              stripComments: false,
              split: false
            };
          }
          if (args.stripComments) {
            args.comments = false;
            cssString = cssString.replace(commentX, "");
          }
          while ((match = altX.exec(cssString)) != null) {
            if (!isEmpty(match[capComment]) && args.comments) {
              var add = match[capComment].trim();
              node[count++] = add;
            } else if (!isEmpty(match[capSelector])) {
              var name = match[capSelector].trim();
              var newNode = base.toJSON(cssString, args);
              if (args.ordered) {
                var obj = {};
                obj["name"] = name;
                obj["value"] = newNode;
                obj["type"] = "rule";
                node[count++] = obj;
              } else {
                if (args.split) {
                  var bits = name.split(",");
                } else {
                  var bits = [name];
                }
                for (i in bits) {
                  var sel = bits[i].trim();
                  if (sel in node.children) {
                    for (var att in newNode.attributes) {
                      node.children[sel].attributes[att] = newNode.attributes[att];
                    }
                  } else {
                    node.children[sel] = newNode;
                  }
                }
              }
            } else if (!isEmpty(match[capEnd])) {
              return node;
            } else if (!isEmpty(match[capAttr])) {
              var line = match[capAttr].trim();
              var attr = lineAttrX.exec(line);
              if (attr) {
                var name = attr[1].trim();
                var value = attr[2].trim();
                if (args.ordered) {
                  var obj = {};
                  obj["name"] = name;
                  obj["value"] = value;
                  obj["type"] = "attr";
                  node[count++] = obj;
                } else {
                  if (name in node.attributes) {
                    var currVal = node.attributes[name];
                    if (!(currVal instanceof Array)) {
                      node.attributes[name] = [currVal];
                    }
                    node.attributes[name].push(value);
                  } else {
                    node.attributes[name] = value;
                  }
                }
              } else {
                node[count++] = line;
              }
            }
          }
          return node;
        };
        base.toCSS = function(node, depth, breaks) {
          var cssString = "";
          if (typeof depth == "undefined") {
            depth = 0;
          }
          if (typeof breaks == "undefined") {
            breaks = false;
          }
          if (node.attributes) {
            for (i in node.attributes) {
              var att = node.attributes[i];
              if (att instanceof Array) {
                for (var j = 0; j < att.length; j++) {
                  cssString += strAttr(i, att[j], depth);
                }
              } else {
                cssString += strAttr(i, att, depth);
              }
            }
          }
          if (node.children) {
            var first = true;
            for (i in node.children) {
              if (breaks && !first) {
                cssString += "\n";
              } else {
                first = false;
              }
              cssString += strNode(i, node.children[i], depth);
            }
          }
          return cssString;
        };
        var strAttr = function(name, value, depth) {
          return "	".repeat(depth) + name + ": " + value + ";\n";
        };
        var strNode = function(name, value, depth) {
          var cssString = "	".repeat(depth) + name + " {\n";
          cssString += base.toCSS(value, depth + 1);
          cssString += "	".repeat(depth) + "}\n";
          return cssString;
        };
      }();
      return CSSJSON;
    });
  }
});
export default require_cssjson();
//# sourceMappingURL=cssjson.js.map
